"story_id","epic","title","user_role","description","business_value","priority","story_points","dependencies","acceptance_criteria","technical_tasks","definition_of_done"
"US-001","Foundational Service Setup & Deployment","Establish Service Foundation and Database Connectivity","Platform Owner","As a Platform Owner, I want the Identity & Access microservice to be initialized with a standard project structure and a robust, configurable connection to the PostgreSQL database, so that developers have a stable foundation to start building features.","Provides the essential technical groundwork for the microservice, enabling database interaction, schema management, and secure configuration, which accelerates all subsequent feature development.","Must Have","8","[]","[{""scenario"":""Service connects to the database successfully"",""given"":""The NestJS application is configured with environment variables for a PostgreSQL database"",""when"":""The application starts"",""then"":""A successful connection to the database is established without errors, and this is confirmed in the application logs.""},{""scenario"":""Initial database schema is created via migrations"",""given"":""The TypeORM entities for User, CustomerProfile, Address, UserConsent, AuditLog, and SystemConfiguration are defined"",""when"":""The initial database migration is run against a clean database"",""then"":""All required tables and relationships are created correctly in the PostgreSQL database.""},{""scenario"":""Service fetches secrets from AWS Secrets Manager in a cloud environment"",""given"":""The application is running in an environment with the `NODE_ENV` set to 'production'"",""when"":""The application bootstraps"",""then"":""It successfully fetches database credentials from AWS Secrets Manager and establishes a connection.""}]","[""Initialize NestJS Application"",""Configure TypeORM for PostgreSQL"",""Implement Database Migrations Setup with TypeORM"",""Integrate AWS Secrets Manager for Credentials""]","[""Application runs locally and connects to a Dockerized PostgreSQL instance."",""Initial database migration script is created and successfully populates the schema."",""Secrets are successfully retrieved from AWS Secrets Manager in a test environment."",""Code is peer-reviewed and has >80% unit test coverage for new services."",""All work is merged into the main development branch.""]"
"US-002","Foundational Service Setup & Deployment","Automate Service Deployment with a CI/CD Pipeline","Platform Owner","As a Platform Owner, I want a fully automated CI/CD pipeline for the Identity & Access service, so that every code change is automatically tested, built, and deployed to the AWS EKS cluster, ensuring rapid, reliable, and consistent releases.","Increases development velocity, improves code quality through automated checks, and reduces the risk of deployment errors. This is a critical capability for maintaining a stable and scalable production environment.","Must Have","13","[""US-001""]","[{""scenario"":""Pull request triggers CI checks"",""given"":""A developer opens a pull request with new code"",""when"":""The CI workflow in GitHub Actions is triggered"",""then"":""The workflow must run linting, execute all unit and integration tests, and fail if any step fails or if code coverage drops below 80%.""},{""scenario"":""Merge to main branch triggers deployment"",""given"":""A pull request has been approved and is merged into the main branch"",""when"":""The CD workflow in GitHub Actions is triggered"",""then"":""A new Docker image is built and pushed to AWS ECR, and a rolling update of the service is successfully triggered in the AWS EKS cluster via Terraform.""},{""scenario"":""Deployed service is healthy and accessible"",""given"":""The CD pipeline has completed successfully"",""when"":""The new version of the service is running in EKS"",""then"":""Its readiness and liveness probes must be passing, and the service must be accessible via its configured Ingress endpoint.""}]","[""Create Multi-Stage Dockerfile"",""Set up GitHub Actions CI Pipeline"",""Create Terraform for EKS Deployment"",""Set up GitHub Actions CD Pipeline""]","[""CI pipeline correctly blocks PRs with failing tests or low coverage."",""CD pipeline successfully deploys the service to the staging EKS cluster upon merge."",""The deployed service is confirmed to be healthy and operational."",""All pipeline configurations are stored as code in the repository."",""Code is peer-reviewed and merged into the main development branch.""]"
"US-003","User Authentication & Session Management","Customer Registers for an Account with Mobile & OTP","New Customer","As a new Customer, I want to register for an account using my mobile number and a One-Time Password (OTP), so that I can securely create a profile and start using the platform.","Enables new user acquisition by providing a secure and standard entry point. Validates the user's primary contact method from the outset, reducing fraudulent accounts and ensuring a reliable communication channel.","Must Have","8","[""US-001""]","[{""scenario"":""Successful registration with a new mobile number"",""given"":""I am on the registration screen"",""when"":""I enter a valid, unregistered mobile number, request an OTP, and enter the correct OTP I receive"",""then"":""My customer account is created, I receive a session token, and I am navigated to the next step of onboarding (e.g., enter my name).""},{""scenario"":""Attempted registration with an existing mobile number"",""given"":""An account already exists with my mobile number"",""when"":""I enter my mobile number on the registration screen and request an OTP"",""then"":""The system shows me an error message: 'This mobile number is already registered. Please log in instead.' and does not proceed.""},{""scenario"":""OTP generation is rate-limited"",""given"":""I have just requested an OTP"",""when"":""I try to request another OTP within 60 seconds"",""then"":""The system prevents a new OTP from being sent and shows me a message to wait.""}]","[""Implement 'Request Registration OTP' Endpoint"",""Implement 'Verify OTP & Complete Registration' Endpoint""]","[""API endpoints for OTP request and verification are implemented and tested."",""New user is successfully created in both PostgreSQL and AWS Cognito."",""Unit and integration tests cover all success, failure, and security scenarios with >80% coverage."",""Code is peer-reviewed and merged.""]"
"US-004","User Authentication & Session Management","Vendor or Rider Registers for an Account","Prospective Vendor or Rider","As a prospective Vendor or Rider, I want to register for an account by providing my details, so that my application can be submitted for administrative review and approval.","Enables the acquisition of supply-side users (vendors and riders), which is critical for the marketplace's operation. Kicks off the mandatory verification workflow to ensure platform quality and safety.","Must Have","3","[""US-003""]","[{""scenario"":""Successful submission of a vendor registration"",""given"":""I am a new user on the registration screen"",""when"":""I select the 'Vendor' role and complete the registration steps"",""then"":""A new user account is created for me with the status 'pending_verification', and I am shown a confirmation screen.""},{""scenario"":""Successful submission of a rider registration"",""given"":""I am a new user on the registration screen"",""when"":""I select the 'Rider' role and complete the registration steps"",""then"":""A new user account is created for me with the status 'pending_verification', and I am shown a confirmation screen.""},{""scenario"":""No session tokens are issued for pending accounts"",""given"":""I have just completed my registration as a vendor or rider"",""when"":""The system processes my application"",""then"":""I am not logged in and do not receive any session tokens until my account is approved by an administrator.""}]","[""Implement Registration for Vendor and Rider Roles""]","[""Registration API endpoint is updated to handle 'vendor' and 'rider' roles."",""Users created via this flow have the 'pending_verification' status in the database."",""Unit tests for these new registration paths are implemented and passing."",""Code is peer-reviewed and merged.""]"
"US-005","User Authentication & Session Management","User Logs in with Mobile & OTP and Manages Session","Registered User (Customer, Vendor, Rider)","As a registered user, I want to log in securely using my mobile number and an OTP, and I want my session to be managed with refresh tokens so I don't have to log in every time I open the app.","Provides secure, password-less access to the platform for all user types. The use of refresh tokens enhances user experience by maintaining a persistent session without compromising security.","Must Have","13","[""US-003""]","[{""scenario"":""Successful login with a valid OTP"",""given"":""I am a registered and active user"",""when"":""I enter my mobile number, request an OTP, and enter the correct OTP"",""then"":""I am successfully logged in and receive a short-lived access token and a long-lived refresh token.""},{""scenario"":""Session is refreshed automatically using a refresh token"",""given"":""I have a valid refresh token and my access token has expired"",""when"":""The application makes an API call"",""then"":""The system uses my refresh token to silently obtain a new access token and successfully completes the API call without requiring me to log in again.""},{""scenario"":""User logs out and session is invalidated"",""given"":""I am logged into the application"",""when"":""I tap the 'Logout' button"",""then"":""My refresh token is invalidated on the server, and I can no longer use it to get a new access token.""}]","[""Implement 'Request Login OTP' Endpoint"",""Implement 'Verify Login OTP' Endpoint with JWT Generation"",""Implement 'Refresh Token' Endpoint"",""Implement Logout and Session Invalidation""]","[""All API endpoints for login, refresh, and logout are implemented and tested."",""JWT generation and validation logic is secure and follows best practices."",""Refresh token revocation (logout) is functional and verified with integration tests."",""Unit and integration tests cover all flows with >80% coverage."",""Code is peer-reviewed and merged.""]"
"US-006","User Authentication & Session Management","Protect User Account from Brute-Force Attacks","Registered User (Customer, Vendor, Rider)","As a registered user, I want my account to be protected from brute-force attacks, so that if someone repeatedly tries to guess my OTP, the system will temporarily lock my account to prevent unauthorized access.","Enhances platform security by actively mitigating brute-force attacks on user accounts, which protects user data, builds trust, and reduces the financial risk associated with SMS/OTP generation abuse.","Must Have","3","[""US-005""]","[{""scenario"":""Account is locked after 5 consecutive failed OTP attempts"",""given"":""I am on the OTP login screen and have entered 4 incorrect OTPs"",""when"":""I enter a 5th incorrect OTP"",""then"":""My account is locked for 15 minutes, and I see an error message: 'Too many failed attempts. Your account is locked for 15 minutes.'""},{""scenario"":""Login is blocked while account is locked"",""given"":""My account is currently locked"",""when"":""I attempt to request a new OTP or submit a correct OTP"",""then"":""The system rejects my request and shows an error message indicating the remaining lockout time.""},{""scenario"":""Account is unlocked after lockout period"",""given"":""My account was locked and the 15-minute period has passed"",""when"":""I request a new OTP"",""then"":""The system successfully sends a new OTP, and my failed attempt counter is reset.""}]","[""Implement Account Lockout Logic""]","[""Logic for tracking failed attempts and setting a lockout key in Redis is implemented."",""Integration tests are created to verify the entire lockout-and-release lifecycle."",""The number of attempts and lockout duration are configurable."",""Code is peer-reviewed and merged.""]"
"US-007","User Profile & Data Management","Customer Manages Personal Profile and Delivery Addresses","Customer","As a Customer, I want to manage my profile (name, email) and my list of delivery addresses, so that I can keep my information up-to-date and ensure accurate deliveries.","Allows users to self-manage their data, improving data accuracy for communication and logistics. A streamlined address management feature is critical for reducing checkout friction and preventing failed deliveries.","Must Have","13","[""US-005""]","[{""scenario"":""Customer views and updates their profile information"",""given"":""I am a logged-in customer on my profile screen"",""when"":""I update my name and email address and save the changes"",""then"":""My profile is successfully updated, and I receive a notification confirming the change.""},{""scenario"":""Customer adds a new delivery address with a map pin"",""given"":""I am on the 'Manage Addresses' screen"",""when"":""I add a new address, providing details and adjusting the pin on the map for precision"",""then"":""The new address, including its geospatial coordinates, is saved to my profile.""},{""scenario"":""Customer edits an existing delivery address"",""given"":""I have a saved address"",""when"":""I choose to edit it, update the details, and save"",""then"":""The address information in my profile is updated with the new details.""},{""scenario"":""Customer deletes a saved delivery address"",""given"":""I have multiple saved addresses"",""when"":""I choose to delete one of them and confirm the action"",""then"":""The address is permanently removed from my profile.""}]","[""Create User & CustomerProfile Entities and Repositories"",""Implement API for Customer Profile Management"",""Create Address Entity with PostGIS Integration"",""Implement CRUD API for Delivery Addresses"",""Implement Security Notification on Profile Changes""]","[""All CRUD API endpoints for profile and addresses are implemented and secured."",""PostGIS is correctly configured and used for storing address locations."",""Integration tests verify a user can only manage their own profile and addresses."",""Automated E2E tests for the address management flow are created and passing."",""Code is peer-reviewed and merged.""]"
"US-008","Administrator Capabilities","Administrator Manages the User Base","Administrator","As an Administrator, I want a dashboard to view, search, and manage all users on the platform, so that I can perform essential operational tasks like approving new registrations and moderating accounts.","Provides administrators with the essential tools for platform governance, quality control, and user support, which are critical for maintaining a healthy and safe marketplace.","Must Have","8","[""US-004"",""US-005""]","[{""scenario"":""Admin views and filters the user list"",""given"":""I am an administrator on the user management dashboard"",""when"":""I apply a filter for 'Role: Vendor' and 'Status: pending_verification'"",""then"":""The list updates to show only the vendor accounts that are awaiting approval.""},{""scenario"":""Admin approves a pending registration"",""given"":""I am viewing a user with 'pending_verification' status"",""when"":""I click the 'Approve' button"",""then"":""The user's status is changed to 'active', and they receive a notification that their account is ready.""},{""scenario"":""Admin suspends an active user"",""given"":""I am viewing an active user's profile"",""when"":""I click the 'Suspend' button and provide a reason"",""then"":""The user's status is changed to 'suspended', their account in AWS Cognito is disabled, and they are logged out of all active sessions.""},{""scenario"":""All admin actions are audited"",""given"":""I am an administrator"",""when"":""I perform any management action on a user (approve, suspend, etc.)"",""then"":""A detailed, immutable record of the action is created in the audit trail.""}]","[""Implement Role-Based Access Control (RBAC) Guard"",""Create Admin API to List and Filter Users"",""Create Admin API to Approve Pending Registrations"",""Create Admin API to Suspend/Deactivate Users""]","[""All API endpoints for admin user management are implemented and protected by the RBAC guard."",""State changes are correctly reflected in both the local database and AWS Cognito."",""Appropriate events (e.g., UserApproved, UserSuspended) are published for downstream services."",""All management actions are correctly logged in the audit trail."",""Code is peer-reviewed and has >80% test coverage.""]"
"US-009","Administrator Capabilities","Administrator Manages System-Wide Configurations","Administrator","As an Administrator, I want to manage system-wide operational parameters, so that I can adjust business rules without requiring code changes.","Provides operational agility, allowing the business to respond to market conditions, manage risk, and optimize efficiency by tuning key parameters through a simple interface.","Should Have","3","[""US-008""]","[{""scenario"":""Admin updates a configuration value"",""given"":""I am an administrator on the system configuration page"",""when"":""I change the value for a key like 'COD_MAX_VALUE' and save the changes"",""then"":""The new value is persisted in the database, and an entry is created in the audit log detailing the change (key, old value, new value).""},{""scenario"":""Attempt to update configuration with invalid data"",""given"":""I am an administrator on the system configuration page"",""when"":""I try to save a non-numeric value for a numeric configuration like 'DELIVERY_RADIUS_KM'"",""then"":""The system rejects the change and displays a validation error.""}]","[""Create Admin API for System Configuration""]","[""CRUD API endpoints for managing system configuration are implemented and secured."",""All update operations are logged in the audit trail."",""Unit and integration tests are created and passing."",""Code is peer-reviewed and merged.""]"
"US-010","Administrator Capabilities","Administrator Views an Immutable Audit Trail","Administrator","As an Administrator, I want to view a searchable and filterable audit trail of all significant administrative actions, so that I can ensure accountability, investigate security incidents, and maintain operational integrity.","Enhances platform security, compliance, and accountability by providing a tamper-proof record of all significant administrative actions. Enables efficient investigation of incidents and debugging of issues caused by configuration changes.","Must Have","8","[""US-008"",""US-009""]","[{""scenario"":""An administrative action is automatically logged"",""given"":""An administrator approves a new vendor"",""when"":""The approval action is successfully completed"",""then"":""A new entry is automatically created in the `AuditLog` table containing the admin's ID, the action taken, the target user's ID, and a timestamp.""},{""scenario"":""Admin views the audit trail"",""given"":""I am an administrator on the audit trail dashboard"",""when"":""I filter the logs by a specific administrator and a date range"",""then"":""The system displays a paginated list of all actions performed by that admin within the specified dates.""},{""scenario"":""Audit logs are immutable"",""given"":""An audit log record exists"",""when"":""An administrator or any other user attempts to modify or delete the record via an API"",""then"":""The system prevents the action, as no API endpoints for modification or deletion exist, and the action is logged as an unauthorized attempt.""}]","[""Implement AuditService and Logging Decorator"",""Create Admin API to View Audit Trail""]","[""AuditService and a custom decorator for automatic logging are implemented and tested."",""API endpoint for viewing logs with filtering is implemented and secured."",""Database permissions on the `AuditLog` table are restricted to prevent direct modification."",""Unit and integration tests are created and passing."",""Code is peer-reviewed and merged.""]"
"US-011","Compliance & Data Governance","Customer Manages Data Processing Consent","Customer","As a Customer, I want to view and manage my consent for specific data processing activities (like promotional emails), so that I have control over my personal data in compliance with DPDP Act.","Ensures legal compliance with the DPDP Act, builds user trust through transparency, and mitigates risks associated with data privacy.","Must Have","5","[""US-003""]","[{""scenario"":""New user has default consents recorded on registration"",""given"":""I am a new customer completing my registration"",""when"":""My account is created"",""then"":""Default consent records (e.g., for 'Promotional Emails', 'Personalized Recommendations') are created and associated with my profile.""},{""scenario"":""Customer views and updates their consent settings"",""given"":""I am a logged-in customer on my privacy settings page"",""when"":""I toggle the consent for 'Promotional Emails' from 'granted' to 'revoked' and save"",""then"":""My preference is updated in the database, and the change is recorded in an audit log.""},{""scenario"":""Customer cannot revoke mandatory consents"",""given"":""I am on my privacy settings page"",""when"":""I view the consent for 'Processing data for order fulfillment'"",""then"":""The option to revoke it is disabled, as it is essential for the service.""}]","[""Implement User Consent Capture on Registration"",""Create API for Managing User Consents""]","[""API endpoints for managing user consents are implemented and secured."",""Consent state is correctly persisted in the database."",""All consent changes are logged for auditing purposes."",""Integration tests verify that mandatory consents cannot be revoked."",""Code is peer-reviewed and merged.""]"
"US-012","Compliance & Data Governance","Customer Exercises Right to Erasure","Customer","As a Customer, I want to request the erasure of my personal data, so that I can exercise my 'right to be forgotten' as per the DPDP Act.","Fulfills a critical legal requirement under the DPDP Act, demonstrates respect for user privacy, and reduces the liability of holding onto unnecessary personal data.","Must Have","8","[""US-003""]","[{""scenario"":""Customer requests data erasure"",""given"":""I am a logged-in customer with no active orders"",""when"":""I initiate the 'Delete Account' process and confirm my choice"",""then"":""An asynchronous anonymization process is triggered, my account is deactivated, and my session is terminated.""},{""scenario"":""System anonymizes user PII"",""given"":""The anonymization process has been triggered for my account"",""when"":""The process completes"",""then"":""All Personally Identifiable Information (PII) in my user profile and address records is overwritten with generic, non-identifiable placeholders.""},{""scenario"":""User is blocked from requesting erasure with active orders"",""given"":""I have an order that is currently 'In Transit'"",""when"":""I attempt to delete my account"",""then"":""The system prevents the action and shows me an error message: 'You cannot delete your account while you have active orders.'""}]","[""Create 'Request Erasure' Endpoint"",""Implement PII Anonymization Logic in Identity Service""]","[""API endpoint for initiating erasure is implemented and secured."",""The asynchronous event-driven workflow for anonymization is functional."",""Integration tests verify that PII is successfully anonymized in the database without deleting records."",""The check for active orders is implemented and tested."",""Code is peer-reviewed and merged.""]"
"US-013","Observability and Monitoring","Enable Service Observability","Platform Operator","As a Platform Operator, I want the Identity & Access service to be fully observable with structured logging, metrics, and distributed tracing, so that I can monitor its health, diagnose issues quickly, and understand its performance in a distributed environment.","Provides essential visibility into the service's operational health, drastically reducing Mean Time To Detection (MTTD) and Mean Time To Resolution (MTTR) for incidents. This ensures high availability and reliability of critical authentication and user management functions.","Should Have","8","[""US-001"",""US-002""]","[{""scenario"":""All requests are logged in a structured format"",""given"":""The service is running"",""when"":""An HTTP request is made to any endpoint"",""then"":""A structured JSON log line is written to CloudWatch containing a `correlationId`, request details, and response details.""},{""scenario"":""Service exposes Prometheus metrics"",""given"":""The service is running"",""when"":""A request is made to the `/metrics` endpoint"",""then"":""The response contains standard application metrics (e.g., HTTP request latency, error counts) in Prometheus format.""},{""scenario"":""Requests are traced across services"",""given"":""A user initiates a request that involves multiple services"",""when"":""The request is processed"",""then"":""A complete, distributed trace for the request can be viewed in the tracing backend (e.g., AWS X-Ray, Jaeger), and the `correlationId` is consistent in the logs of all involved services.""}]","[""Configure Structured JSON Logging"",""Expose Prometheus Metrics Endpoint"",""Implement Distributed Tracing with OpenTelemetry""]","[""All observability components are integrated and configured in the application."",""Logs, metrics, and traces are successfully being collected in the staging environment."",""The `correlationId` is correctly propagated and logged."",""Unit and integration tests are updated to work with the new instrumentation."",""Code is peer-reviewed and merged.""]"