[{'name': 'API Gateway', 'type': 'Structural/Routing', 'implementation': 'Amazon API Gateway acts as the single entry point for all client requests (HTTP/REST and WSS), routing them to the correct backend microservices. It integrates with AWS Cognito for authentication.', 'applicability': 'Mandated by REQ-1-106 to provide a unified and secure interface for the four distinct client applications (REQ-1-002). It is responsible for centralized concerns such as request routing, JWT validation (REQ-1-096), rate limiting (REQ-1-041), and initiating distributed tracing by generating a correlation ID (REQ-1-110).'}, {'name': 'Publish-Subscribe', 'type': 'Asynchronous Messaging', 'implementation': 'Asynchronous, event-driven communication using AWS SNS (for topics) and AWS SQS (for durable queues). Services publish events to an SNS topic, and interested services consume these events from their dedicated SQS queue.', 'applicability': "Fulfills the core requirement for asynchronous communication (REQ-1-105) to decouple microservices. Essential for workflows where an immediate response is not required, such as notifying the Rider Logistics service when an order is 'Ready for Pickup' or triggering the Payouts service at the end of a settlement period."}, {'name': 'Saga', 'type': 'Distributed Transaction Management', 'implementation': 'A choreography-based Saga that leverages the Publish-Subscribe pattern. Each service in a transaction performs its local update and then publishes an event, which triggers the next service in the chain. Compensating transactions are triggered by failure events.', 'applicability': 'Explicitly required by REQ-1-105 to ensure data consistency across multiple services for long-running business processes. It is critical for the order lifecycle, coordinating actions between the Order, Vendor (inventory check), and Payments services without using distributed locks.'}, {'name': 'Circuit Breaker', 'type': 'Resilience', 'implementation': 'Implemented at two levels: 1) via AWS App Mesh for all inter-service communication as specified in REQ-1-106, and 2) within the application code of microservices for all calls to external third-party APIs (e.g., Razorpay, Mapbox).', 'applicability': 'Mandated by REQ-1-028 and REQ-1-106 to prevent cascading failures. When a downstream service or third-party API becomes unavailable or latent, the circuit breaker trips, allowing the system to fail fast and avoid exhausting resources, thus improving overall platform stability.'}, {'name': 'Backend for Frontend (BFF)', 'type': 'API Design', 'implementation': 'Functionality is provided by the API Gateway layer, which exposes tailored endpoints that aggregate and shape data specifically for each of the four distinct client applications (Customer mobile, Vendor web, Rider mobile, Admin web).', 'applicability': 'Essential for providing an optimal and performant experience for each user type as defined in REQ-1-002. It avoids creating a single, bloated, generic API by providing each frontend with a data payload precisely matching its UI requirements, which is particularly important for optimizing mobile client performance.'}, {'name': 'Correlation Identifier', 'type': 'Observability', 'implementation': 'A unique identifier (correlationId) is generated at the API Gateway for every incoming request. This ID is then consistently propagated through all subsequent synchronous API calls (via HTTP headers) and asynchronous messages (via message attributes), managed by the OpenTelemetry standard.', 'applicability': 'Explicitly required by REQ-1-110 to enable distributed tracing. This pattern is critical for debugging, monitoring, and understanding the end-to-end flow of a single user request as it traverses multiple microservices, which is otherwise impossible in a distributed system.'}]

